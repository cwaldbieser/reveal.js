<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
                    <script type="text/template">
                        # Scriptable Grouper
                        ## Lafayette College&apos;s Big Fish Story
                    </script>
                </section>
                <section>
                    <ul>
                        <li><h3>Who am I?</h3></li>
                        <li><h3>What is Internet2 Grouper?</h3></li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>I am Carl Waldbieser</li>
                            <li>I am the Systems Programmer at Lafayette College.</li>
                            <li>Much of the work I do for the College revolves around identity management and access control.</li>
                        </ul>
                        <ul>
                            <li>Internet2 Grouper is middleware that allows you to allows you to compose, combine, and manage groups, roles, and permissions.</li>
                            <li>It can be used as a single point of control to manage memberships across applications.</li>
                            <li>It allows management of groups to be delegated to collaborators.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Charting a Course</h2>
                    <img src="/img/treasure_map.png" />
                    <aside class="notes">
                        <ul>
                            <li>We have these great tools-- now what?</li>
                            <li>We looked at how lots of other institutions were organizing their Groupers.</li>
                            <li>
                                We settled on a basic 3-part hierarchy: apps, orgs, and refs.  
                                    <ul>
                                        <li> Orgs mirrors an org-chart.</li>
                                        <li>Refs are reference groups that are either data-driven or maintained directly in Grouper.</li>
                                        <li>Apps are where application specific policies are composed and exported to provisioners.</li>
                                    </ul>
                            </li>
                            <li>The New UI is really great for a lot of routine tasks.  But when there are gaps in the functionality, you need to use the Grouper API.  The typical way of doing this is to use the Grouper shell (GSH).</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>This is the Shell?!</h2>
                    <img src="/img/seashell.png" />
                    <aside class="notes">
                        <ul>
                            <li>GSH allows you to work directly with the Grouper API at a fairly low level.</li>
                            <li>If you don't have familiarity with Java, the API can be rather daunting.</li>
                            <li>Even if you are proficient in Java, the API vocabulary is made of primitives.</li>
                            <li>For busy sys-admins, the primitives are too *primitive*.</li>
                            <li>GSH is a no-frills REPL that doesn't lend itself well to experimentation or introspection.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>A Plethora of Cool Shells</h2>
                    <img src="/img/many-shells.png" />
                    <aside class="notes">
                        <ul>
                            <li>Modern REPLs were a problem that had been solved many, *many* times.</li>
                            <li>First attempt-- I wrapped GSH using Python's `cmd` module.  Readline and history support.</li>
                            <li>Dave Langenberg on grouper-users mail list suggested I try Bill Thompson's `groovysh4grouper`.</li>
                            <li>groovysh4grouper imported the Grouper API into its own REPL.</li>
                            <li>I added support for Clojure and Jython (I am a big Python fan).</li>
                            <li>
                                I created functions to orchestrate common tasks:
                                <ul>
                                    <li>Create application skeletons</li>
                                    <li>Link groups to the Grouper Loader.</li>
                                    <li>Create time-based rules.</li>
                                </ul>
                            </li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>How Much Could We Wrap?</h2>
                    <img src="/img/kraken.png" />
                    <aside class="notes">
                        <ul>
                            <li>When Lafayette began its Grouper pilot, the Provisioning Service Provider (PSP) was the only supported option for provisioning external systems.</li>
                            <li>The PSP was an incomplete SPMLv2 provisioning service provider that was fed by a Shibboleth attribute resolver.</li>
                            <li>It was a lot more complicated than what Lafayette needed.</li>
                            <li>
                                Bill Thompson suggested that we should "beg, borrow, or steal"
                                a change log consumer from the community.
                            </li>
                            <li>
                                While exploring several options, I realized there was a really
                                simple change log consumer baked into Grouper: 
                                `edu.internet2.middleware.grouper.changeLog.ChangeLogConsumer`
                            </li>
                            <li>I bet it wouldn't be hard to script it using Jython!</li>
                            <li>The original Jython changelog consumer was just 218 lines of code.</li>
                            <li>The original message format was `group` + newline + `subject` + newline + `action`.</li>
                            <li>
                                In May of 2015, Bill told me that the Grouper project was leaning 
                                toward connecting provisioners to change log consumers via message queues.
                            </li>
                            <li>I looked at ActiveMQ and RabbitMQ, and decided I liked the latter.</li>
                            <li>
                                Over June and July of 2015, I rewrote portions of the code base 
                                so that our changelog consumer sent AMQP messages, and our LDAP 
                                provisioners read AMQP messages.
                            </li>
                            <li>The scripted changelogger grew to 372 lines of code.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>A Diverse Ecosystem</h2>
                    <img src="/img/fish.png" />
                    <aside class="notes">
                            Why all these scripting languages?  Why not just stick with plain old Java?  
                            Doesn't this waste limited community resources?

                            <li>
                                At Lafayette, we had specific goals for Grouper.  And they may or
                                may not align with the goals of your institution.  What works for 
                                your institution might be completely different.
                            </li>
                            <li>Who in Higher Ed wants to work in a place they want to become *less* diverse?</li>
                            <li>
                                By not supporting a language, a platform, or a tool set, 
                                you don't convert people to your community.  
                                You risk *losing* or *alienating* people who might otherwise 
                                want to be part of your community.
                            </li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Links</h2>
                    <ul>
                        <li>Link goes here.</li>
                    </ul>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
