<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
                    <script type="text/template">
                        # Scriptable Grouper
                        ## Lafayette College&apos;s Big Fish Story
                    </script>
                </section>
                <section>
                    <ul>
                        <li><h3>Who am I?</h3></li>
                        <li><h3>What is Internet2 Grouper?</h3></li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>I am Carl Waldbieser</li>
                            <li>I am the Systems Programmer at Lafayette College.</li>
                            <li>Much of the work I do for the College revolves around identity management and access control.</li>
                        </ul>
                        <ul>
                            <li>Internet2 Grouper is middleware that allows you to allows you to compose, combine, and manage groups, roles, and permissions.</li>
                            <li>It can be used as a single point of control to manage memberships across applications.</li>
                            <li>It allows management of groups to be delegated to collaborators.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Charting a Course</h2>
                    <img src="/img/treasure_map.png" />
                    <aside class="notes">
                        <ul>
                            <li>We have these great tools-- now what?</li>
                            <li>We looked at how lots of other institutions were organizing their Groupers.</li>
                            <li>
                                We settled on a basic 3-part hierarchy: apps, orgs, and refs.  
                                    <ul>
                                        <li> Orgs mirrors an org-chart.</li>
                                        <li>Refs are reference groups that are either data-driven or maintained directly in Grouper.</li>
                                        <li>Apps are where application specific policies are composed and exported to provisioners.</li>
                                    </ul>
                            </li>
                            <li>The New UI is really great for a lot of routine tasks.  But when there are gaps in the functionality, you need to use the Grouper API.  The typical way of doing this is to use the Grouper shell (GSH).</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>First Impressions</h2>
                    <img src="/img/c64.png" />
                    <aside class="notes">
                        <ul>
                            <li>GSH allows you to work directly with the Grouper API at a fairly low level.</li>
                            <li>If you don't have familiarity with Java, the API can be rather daunting.</li>
                            <li>Even if you are proficient in Java, the API vocabulary is made of primitives.</li>
                            <li>GSH is a no-frills REPL that doesn't lend itself well to experimentation or introspection.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Reduce, Reuse, Recycle</h2>
                    <img src="/img/recycle.png" />
                    <aside class="notes">
                        <ul>
                            <li>Modern REPLs were a problem that had been solved many, *many* times.</li>
                            <li>First attempt-- I wrapped GSH using Python's `cmd` module.  Readline and history support.</li>
                            <li>Dave Langenberg on grouper-users mail list suggested I try Bill Thompson's `groovysh4grouper`.</li>
                            <li>Interesting fact-- Bill Thompson, formerly of Unicon, had recently become the Director of Digital Infrastructure at Lafayette College.</li>
                            <li>The Big Idea-- a lot of scripting languages exist for the JVM.  They all support modern REPL environments and tab-completion.  Import the Grouper primitives into the REPL environment of your choice.</li>
                            <li>Bill had managed to do this for the Groovy scripting language.</li>
                            <li>I added support for Clojure and Jython (I am a big Python fan).</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Putting the Pieces Together</h2>
                    <img src="/img/puzzle.png" />
                    <aside class="notes">
                        <ul>
                            <li>For sys-admins, the primitives are too *primitive*.</li>
                            <li>Need for higher order functions:</li>
                            <ul>
                                <li>Create application skeletons</li>
                                <li>Link groups to the Grouper Loader.</li>
                                <li>Create time-based rules.</li>
                            </ul>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>How Far Can We Take This?</h2>
                    <img src="/img/hidden-galaxy.png" />
                    <aside class="notes">
                        <ul>
                            <li>When Lafayette began its Grouper pilot, the Provisioning Service Provider (PSP) was the only supported option for provisioning external systems.</li>
                            <li>The PSP was an incomplete SPMLv2 provisioning service provider that was fed by a Shibboleth attribute resolver.</li>
                            <li>It was a lot more complicated than what a lot of deployers (including Lafayette) needed.</li>
                            <li>Bill Thompson suggested that the PSP was going the way of the dinosaurs, and we should "beg, borrow, or steal" something called a "change log consumer" from the community.</li>
                            <li>I considered CMU GAP.  We could have gone that way, except for the fact that it required both Java and Perl savvy.</li>
                            <li>Around that time, I realized there was a really simple change log consumer baked into Grouper: `edu.internet2.middleware.grouper.changeLog.ChangeLogConsumer`</li>
                            <li>I bet it wouldn't be hard to script it using Jython!</li>
                            <li>The original Jython changelog consumer was just 218 lines of code (182 excluding blank lines and comments).</li>
                            <li>The original LDAP group provisioner was 628 lines of Python code (533 excluding blanks and comments).</li>
                            <li>I wrote the entire code base in 25 days.  The idea was when the Grouper project came out with something better, we'd ditch our change log consumer for theirs.</li>
                            <li>In May of 2015, Bill told me that the Grouper project was leaning toward connecting provisioners to change log consumers via message queues.</li>
                            <li>I looked at ActiveMQ and RabbitMQ, and decided I liked the latter.</li>
                            <li>Over June and July of 2015, I rewrote portions of the code base so that our changelog consumer sent AMQP messages, and our LDAP provisioners read AMQP messages.</li>
                            <li>The scripted changelogger grew to 372 lines of code.</li>
                        </ul>
                    </aside>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
